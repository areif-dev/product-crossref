mod fixers;
mod product;

use std::error::Error;

use abc_uiautomation::{
    ensure_abc,
    inventory::{load_inventory_screen, load_item},
    send_ctrl_n, wait, UIElement, SHORT_WAIT_MS,
};
use clap::Parser;
use fixers::{fix_cost, fix_group, fix_retail, fix_upc, fix_weight, write_logs};
use product::{map_upcs, parse_abc_item_files, AbcParseError, AbcProduct, ExportedProduct};
use rust_decimal::dec;

#[derive(clap::Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    /// The path to the "item.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item.data"
    )]
    pub item_data: String,

    /// The path to the "item_posted.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item_posted.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item_posted.data"
    )]
    pub posted_data: String,

    /// Path to the CSV export of the order to import data from. Must include headers for "sku",
    /// "description", "upc", "cost", "list", "weight"
    #[arg(
        short,
        long,
        default_value = "C:\\Users\\User\\Downloads\\order-export.csv"
    )]
    pub export: String,

    /// Set this to execute the program normally, except that no prices will actually be changed in
    /// Shopify. Useful for debugging
    #[arg(short, long = "dry")]
    pub dry_run: bool,
}

impl Cli {
    fn parse_export_file(&self) -> Result<Vec<ExportedProduct>, AbcParseError> {
        let mut reader = csv::ReaderBuilder::new().from_path(&self.export)?;
        let mut prods = Vec::new();
        for row in reader.deserialize() {
            prods.push(row?);
        }
        Ok(prods)
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let exported_products = cli
        .parse_export_file()
        .or_else(|e| Err(format!("Failed to parse the export file due to `{}`", e)))?;
    let abc_products = parse_abc_item_files(&cli.item_data, &cli.posted_data)
        .or_else(|e| Err(format!("Failed to parse abc item export due to `{}`", e)))?;
    let abc_prods_by_upc = map_upcs(&abc_products);

    let mut new_prods = Vec::new();
    let mut all_dups = Vec::new();
    let mut double_check = Vec::new();
    let mut matched = Vec::new();
    let abc_window = ensure_abc()?;
    let inventory_screen = load_inventory_screen(&abc_window)?;
    wait(SHORT_WAIT_MS * 5);
    send_ctrl_n(&abc_window, false)?;
    for ex_prod in exported_products {
        let mut fixes: Vec<
            fn(&UIElement, &AbcProduct, &ExportedProduct) -> Result<(), abc_uiautomation::Error>,
        > = Vec::new();
        let Some((dups, abc_prod)) = abc_prods_by_upc.get(&ex_prod.upc) else {
            new_prods.push(ex_prod);
            continue;
        };
        if !dups.is_empty() {
            all_dups.push(dups);
            continue;
        }
        if let Some(retail) = ex_prod.retail {
            if retail >= abc_prod.list() * dec!(2)
                || ex_prod.cost >= abc_prod.cost() * dec!(2)
                || retail <= abc_prod.list() / dec!(2)
                || ex_prod.cost <= abc_prod.cost() / dec!(2)
            {
                double_check.push(ex_prod);
                continue;
            }
        }
        matched.push(ex_prod.clone());

        // Skip actually making changes in ABC if the user asked for a dry run
        if cli.dry_run {
            continue;
        }
        if !abc_prod.upcs().ends_with(&[ex_prod.upc]) {
            fixes.push(fix_upc);
        }
        if ex_prod.weight.is_some() && abc_prod.weight() != ex_prod.weight {
            fixes.push(fix_weight);
        }
        if ex_prod.cost != abc_prod.cost() {
            fixes.push(fix_cost);
        }
        if let Some(retail) = ex_prod.retail {
            if retail != abc_prod.list() {
                fixes.push(fix_retail);
            }
        }
        if abc_prod.group().is_none() || abc_prod.group().is_some_and(|g| g.is_empty()) {
            fixes.push(fix_group);
        }
        if !fixes.is_empty() {
            send_ctrl_n(&inventory_screen, false)?;
            load_item(&inventory_screen, &abc_prod.sku())?;
            for f in fixes {
                f(&inventory_screen, abc_prod, &ex_prod)?;
            }
            inventory_screen.send_keys("{F9}", SHORT_WAIT_MS)?;
        }
    }

    write_logs(all_dups, new_prods, double_check, matched)?;
    Ok(())
}
