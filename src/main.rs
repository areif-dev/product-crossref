mod product;

use std::{error::Error, fs::File, path::PathBuf};

use abc_uiautomation::{
    accounts_receivable::load_invoice,
    ensure_abc,
    inventory::{clear_upc, load_inventory_screen, load_item, set_upc},
    send_ctrl_n, wait, UIElement, SHORT_WAIT_MS,
};
use clap::Parser;
use ean13::Ean13;
use product::{map_upcs, parse_abc_item_files, AbcParseError, AbcProduct, ExportedProduct};
use rust_decimal::{dec, Decimal};

#[derive(clap::Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    /// The path to the "item.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item.data"
    )]
    pub item_data: String,

    /// The path to the "item_posted.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item_posted.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item_posted.data"
    )]
    pub posted_data: String,

    /// Path to the CSV export of the order to import data from. Must include headers for "sku",
    /// "description", "upc", "cost", "list", "weight"
    #[arg(
        short,
        long,
        default_value = "C:\\Users\\User\\Downloads\\order-export.csv"
    )]
    pub export: String,

    /// Set this to execute the program normally, except that no prices will actually be changed in
    /// Shopify. Useful for debugging
    #[arg(short, long = "dry")]
    pub dry_run: bool,
}

impl Cli {
    fn parse_export_file(&self) -> Result<Vec<ExportedProduct>, AbcParseError> {
        let mut reader = csv::ReaderBuilder::new().from_path(&self.export)?;
        let mut prods = Vec::new();
        for row in reader.deserialize() {
            prods.push(row?);
        }
        Ok(prods)
    }
}

fn fix_upc(
    inventory_window: &UIElement,
    abc_prod: &AbcProduct,
    ex_prod: &ExportedProduct,
) -> Result<(), Box<dyn Error>> {
    clear_upc(inventory_window, true)?;
    for upc in abc_prod.upcs() {
        if upc != ex_prod.upc {
            set_upc(inventory_window, upc)?;
        }
    }
    set_upc(inventory_window, ex_prod.upc)?;
    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let exported_products = cli
        .parse_export_file()
        .or_else(|e| Err(format!("Failed to parse the export file due to `{}`", e)))?;
    let abc_products = parse_abc_item_files(&cli.item_data, &cli.posted_data)
        .or_else(|e| Err(format!("Failed to parse abc item export due to `{}`", e)))?;
    let abc_prods_by_upc = map_upcs(&abc_products);

    let mut new_prods = Vec::new();
    let mut all_dups = Vec::new();
    let mut double_check = Vec::new();
    let abc_window = ensure_abc()?;
    let inventory_screen = load_inventory_screen(&abc_window)?;
    wait(SHORT_WAIT_MS * 5);
    send_ctrl_n(&abc_window, false)?;
    for ex_prod in exported_products {
        let mut fixes = Vec::new();
        let Some((dups, abc_prod)) = abc_prods_by_upc.get(&ex_prod.upc) else {
            new_prods.push(ex_prod);
            println!("{:#?}", new_prods);
            continue;
        };
        if !dups.is_empty() {
            all_dups.push(dups);
            println!("{:#?}", all_dups);
            continue;
        }
        if let Some(retail) = ex_prod.retail {
            if retail >= abc_prod.list() * dec!(2) || ex_prod.cost >= abc_prod.cost() * dec!(2) {
                double_check.push(ex_prod);
                continue;
            }
        }
        if !abc_prod.upcs().ends_with(&[ex_prod.upc]) {
            fixes.push(fix_upc);
        }
        if !fixes.is_empty() {
            send_ctrl_n(&inventory_screen, false)?;
            load_item(&inventory_screen, &abc_prod.sku())?;
            for fix in fixes {
                fix(&inventory_screen, abc_prod, &ex_prod)?;
            }
            inventory_screen.send_keys("{F9}", SHORT_WAIT_MS)?;
        }
    }
    Ok(())
}
