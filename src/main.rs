mod product;

use std::{error::Error, fs::File, path::PathBuf};

use abc_uiautomation::{
    accounts_receivable::load_invoice, ensure_abc, inventory::load_inventory_screen,
};
use clap::Parser;
use ean13::Ean13;
use product::{map_upcs, parse_abc_item_files, AbcParseError, AbcProduct, ExportedProduct};
use rust_decimal::{dec, Decimal};

#[derive(clap::Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    /// The path to the "item.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item.data"
    )]
    pub item_data: String,

    /// The path to the "item_posted.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item_posted.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item_posted.data"
    )]
    pub posted_data: String,

    /// Path to the CSV export of the order to import data from. Must include headers for "sku",
    /// "description", "upc", "cost", "list", "weight"
    #[arg(
        short,
        long,
        default_value = "C:\\Users\\User\\Downloads\\order-export.csv"
    )]
    pub export: String,

    /// Set this to execute the program normally, except that no prices will actually be changed in
    /// Shopify. Useful for debugging
    #[arg(short, long = "dry")]
    pub dry_run: bool,
}

impl Cli {
    fn parse_export_file(&self) -> Result<Vec<ExportedProduct>, AbcParseError> {
        let mut reader = csv::ReaderBuilder::new().from_path(&self.export)?;
        let mut prods = Vec::new();
        for row in reader.deserialize() {
            prods.push(row?);
        }
        Ok(prods)
    }
}

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let exported_products = cli
        .parse_export_file()
        .or_else(|e| Err(format!("Failed to parse the export file due to `{}`", e)))?;
    let abc_products = parse_abc_item_files(&cli.item_data, &cli.posted_data)
        .or_else(|e| Err(format!("Failed to parse abc item export due to `{}`", e)))?;
    let abc_prods_by_upc = map_upcs(&abc_products);

    //let mut new_prods = Vec::new();
    //let mut all_dups = Vec::new();
    //let mut double_check = Vec::new();
    //for ex_prod in exported_products {
    //    let Some((dups, abc_prod)) = abc_prods_by_upc.get(&ex_prod.upc) else {
    //        new_prods.push(ex_prod);
    //        continue;
    //    };
    //    if !dups.is_empty() {
    //        all_dups.push(dups);
    //        continue;
    //    }
    //    if ex_prod.retail >= abc_prod.list() * dec!(2) || ex_prod.cost >= abc_prod.cost() * dec!(2)
    //    {
    //        double_check.push(ex_prod);
    //        continue;
    //    }
    //    let abc_window = ensure_abc()?;
    //    let inventory_screen = load_inventory_screen(&abc_window)?;
    //    load_invoice(&inventory_screen, 10)?;
    //}
    Ok(())
}
