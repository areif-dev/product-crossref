mod product;

use std::{
    error::Error,
    fs::{self, File},
    path::PathBuf,
};

use abc_uiautomation::{
    accounts_receivable::load_invoice,
    ensure_abc,
    inventory::{clear_upc, load_inventory_screen, load_item, set_upc},
    send_ctrl_n, set_text_box_value, wait, UIElement, SHORT_WAIT_MS,
};
use clap::Parser;
use ean13::Ean13;
use product::{
    map_upcs, parse_abc_item_files, AbcParseError, AbcProduct, DuplicateProducts, ExportedProduct,
};
use rust_decimal::{dec, Decimal};

#[derive(clap::Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    /// The path to the "item.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item.data"
    )]
    pub item_data: String,

    /// The path to the "item_posted.data" file generated by report 7-10. Usually C:\\projects\\export-data\\data\\item_posted.data
    #[arg(
        short,
        long,
        default_value = "C:\\projects\\export-data\\data\\item_posted.data"
    )]
    pub posted_data: String,

    /// Path to the CSV export of the order to import data from. Must include headers for "sku",
    /// "description", "upc", "cost", "list", "weight"
    #[arg(
        short,
        long,
        default_value = "C:\\Users\\User\\Downloads\\order-export.csv"
    )]
    pub export: String,

    /// Set this to execute the program normally, except that no prices will actually be changed in
    /// Shopify. Useful for debugging
    #[arg(short, long = "dry")]
    pub dry_run: bool,
}

impl Cli {
    fn parse_export_file(&self) -> Result<Vec<ExportedProduct>, AbcParseError> {
        let mut reader = csv::ReaderBuilder::new().from_path(&self.export)?;
        let mut prods = Vec::new();
        for row in reader.deserialize() {
            prods.push(row?);
        }
        Ok(prods)
    }
}

fn fix_upc(
    inventory_window: &UIElement,
    abc_prod: &AbcProduct,
    ex_prod: &ExportedProduct,
) -> Result<(), Box<dyn Error>> {
    clear_upc(inventory_window, true)?;
    for upc in abc_prod.upcs() {
        if upc != ex_prod.upc {
            set_upc(inventory_window, upc)?;
        }
    }
    set_upc(inventory_window, ex_prod.upc)?;
    Ok(())
}

fn fix_weight(
    inventory_window: &UIElement,
    _abc_prod: &AbcProduct,
    ex_prod: &ExportedProduct,
) -> Result<(), Box<dyn Error>> {
    if let Some(weight) = ex_prod.weight {
        set_text_box_value(inventory_window, 15, weight.to_string())?;
    }
    Ok(())
}

fn fix_cost(
    inventory_window: &UIElement,
    _abc_prod: &AbcProduct,
    ex_prod: &ExportedProduct,
) -> Result<(), Box<dyn Error>> {
    set_text_box_value(inventory_window, 26, ex_prod.cost.to_string())?;
    Ok(())
}

fn fix_retail(
    inventory_window: &UIElement,
    _abc_prod: &AbcProduct,
    ex_prod: &ExportedProduct,
) -> Result<(), Box<dyn Error>> {
    if let Some(retail) = ex_prod.retail {
        set_text_box_value(inventory_window, 25, retail.to_string())?;
    }
    Ok(())
}

fn fix_group(
    inventory_window: &UIElement,
    _abc_prod: &AbcProduct,
    _ex_prod: &ExportedProduct,
) -> Result<(), Box<dyn Error>> {
    set_text_box_value(inventory_window, 39, "Z")?;
    Ok(())
}

fn write_logs(
    dups: Vec<&DuplicateProducts>,
    new: Vec<ExportedProduct>,
    check: Vec<ExportedProduct>,
) -> std::io::Result<()> {
    fs::write(
        "./duplicate_products.txt",
        format!(
            "The following products all share the same UPC. You may want to fix that.\n\n{:#?}",
            dups
        ),
    )?;
    fs::write(
        "./new_products.txt",
        format!(
            "The following products are new to ABC. Please enter them manually.\n\n{:#?}",
            new
        ),
    )?;
    fs::write("./double_check.txt", format!("The following products seem to have changed wildly. Please double check that their listings are correct.\n\n{:#?}", check))?;
    Ok(())
}

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Cli::parse();
    let exported_products = cli
        .parse_export_file()
        .or_else(|e| Err(format!("Failed to parse the export file due to `{}`", e)))?;
    let abc_products = parse_abc_item_files(&cli.item_data, &cli.posted_data)
        .or_else(|e| Err(format!("Failed to parse abc item export due to `{}`", e)))?;
    let abc_prods_by_upc = map_upcs(&abc_products);

    let mut new_prods = Vec::new();
    let mut all_dups = Vec::new();
    let mut double_check = Vec::new();
    let abc_window = ensure_abc()?;
    let inventory_screen = load_inventory_screen(&abc_window)?;
    wait(SHORT_WAIT_MS * 5);
    send_ctrl_n(&abc_window, false)?;
    for ex_prod in exported_products {
        let mut fixes: Vec<
            fn(&UIElement, &AbcProduct, &ExportedProduct) -> Result<(), Box<dyn Error>>,
        > = Vec::new();
        let Some((dups, abc_prod)) = abc_prods_by_upc.get(&ex_prod.upc) else {
            new_prods.push(ex_prod);
            println!("{:#?}", new_prods);
            continue;
        };
        if !dups.is_empty() {
            all_dups.push(dups);
            println!("{:#?}", all_dups);
            continue;
        }
        if let Some(retail) = ex_prod.retail {
            if retail >= abc_prod.list() * dec!(2) || ex_prod.cost >= abc_prod.cost() * dec!(2) {
                double_check.push(ex_prod);
                continue;
            }
        }
        if !abc_prod.upcs().ends_with(&[ex_prod.upc]) {
            fixes.push(fix_upc);
        }
        if ex_prod.weight.is_some() && abc_prod.weight() != ex_prod.weight {
            fixes.push(fix_weight);
        }
        if ex_prod.cost != abc_prod.cost() {
            fixes.push(fix_cost);
        }
        if let Some(retail) = ex_prod.retail {
            if retail != abc_prod.list() {
                fixes.push(fix_retail);
            }
        }
        if abc_prod.group().is_none() || abc_prod.group().is_some_and(|g| g.is_empty()) {
            fixes.push(fix_group);
        }
        if !fixes.is_empty() {
            send_ctrl_n(&inventory_screen, false)?;
            load_item(&inventory_screen, &abc_prod.sku())?;
            for f in fixes {
                f(&inventory_screen, abc_prod, &ex_prod)?;
            }
            inventory_screen.send_keys("{F9}", SHORT_WAIT_MS)?;
        }
    }

    write_logs(all_dups, new_prods, double_check)?;
    Ok(())
}
